import type { CoreMessage } from "ai";
import { type } from "arktype";
import {
  type Context,
  type Provider,
  type ProviderInstance,
  type ProviderOrThunk,
  Resource,
  type ResourceType,
  resolveProvider,
} from "../resource";
import { extractTypeScriptCode } from "../typescript/extract";
import { generateText } from "./ai";
import { type ModelId, resolveModel } from "./model";

export interface AgentOptions<
  Input extends type<any>,
  Resources extends ProviderOrThunk[],
> {
  model: ModelId;
  effort?: "low" | "medium" | "high";
  resources: Resources;
  alwaysUpdate?: boolean;
  input: Input;
}

export type Prompt = string | CoreMessage[];

export type ResourceGraph<Resources extends ProviderOrThunk[]> = {
  [key: string]: ProviderInstance<Resources[number]>;
};

export type AgentOutput<Resources extends ProviderOrThunk[]> = {
  // the script that constructs the resource graph
  // JavaScript code generated by an LLM
  script: string;
  // resource ID -> resource instance
  resources: ResourceGraph<Resources>;
};

export function Agent<
  const Type extends ResourceType,
  In extends type<any, any>,
  Resources extends ProviderOrThunk[],
>(
  agentType: Type,
  options: AgentOptions<In, Resources>,
  constructPrompt: (
    ctx: Context<type.infer<In>, AgentOutput<Resources>>,
    input: type.infer<In>,
    ...args: any[]
  ) => Promise<Prompt | void>,
): Provider<Type, type.infer<In>, AgentOutput<Resources>> {
  for (const resource of options.resources) {
    const provider = resolveProvider(resource);
    if (provider.input === undefined) {
      throw new Error(`Resource input schema is undefined: ${provider.type}`);
    }
    if (provider.output === undefined) {
      throw new Error(`Resource output schema is undefined: ${provider.type}`);
    }
  }

  return Resource(
    agentType,
    {
      alwaysUpdate: options.alwaysUpdate,
      input: options.input,
      output: type({
        script: "string",
        resources: type({
          "[string]": options.resources.reduce<type<any>>((acc, r) => {
            const output = resolveProvider(r).output;
            if (acc) {
              return acc.or(output);
            }
            return output;
          }, null!) as any,
        }),
      }),
    },
    async (
      ctx,
      input,
      ...args: any[]
    ): Promise<AgentOutput<Resources> | void> => {
      if (ctx.event === "delete") {
        return;
      }

      const model = await resolveModel(options.model);
      const prompt = await constructPrompt(ctx, input, ...args);

      let script: string;
      if (!prompt) {
        if (ctx.event === "create") {
          throw new Error("A prompt is required for the initial creation.");
        } else {
          if (!ctx.quiet) {
            console.log("Skipping update as no prompt was required.");
          }
          script = ctx.output.script;
        }
      } else {
        for (const resourceOrThunk of options.resources) {
          const resource = resolveProvider(resourceOrThunk);
          if (resource.input === undefined) {
            throw new Error(
              `Resource input schema is undefined: ${resource.name}`,
            );
          }
          if (resource.output === undefined) {
            throw new Error(
              `Resource output schema is undefined: ${resource.name}`,
            );
          }
        }

        const system = [
          "You are an agent that can manages a declarative Resource Graph.",
          "You are provided with a list of Resource class types and their input/output properties.",
          "You respond to the user with a graph of resources and their dependencies.",
          "A Resource Graph is constructed with a short JavaScript script that constructs objects and",
          "connects them together by passing the outputs of one object as the inputs to another.",
          "This is a bit like the AWS CDK or Pulumi, except simplified.",
          "Here is an example of a Resource Graph for a simple API:",
          "```javascript",
          "const table = new Table('table', { name: 'my-table' });",
          "const bucket = new Bucket('bucket', { name: 'my-bucket' });",
          "const role = new Role('role', { name: 'my-role' });",
          "const lambda = new Lambda('lambda', {",
          "  name: 'my-lambda',",
          "  role: role,",
          "  handler: 'index.handler',",
          "  code: 'index.zip'",
          "});",
          "```",
          "You have access to the following resources:",
          options.resources
            .map((r) => {
              const provider = resolveProvider(r);
              return [
                ...(provider.example
                  ? [
                      `/**`,
                      ...provider.example.split("\n").map((l) => ` * ${l}`),
                      `*/`,
                    ]
                  : []),
                `type ${provider.type} = new (id: string, input: ${provider.input.expression}) => ${provider.output.expression}`,
              ];
            })
            .join("\n"),
        ].join("\n");

        const updateContext: CoreMessage[] =
          ctx.event === "update"
            ? [
                {
                  role: "user",
                  content: [
                    "Here is the previous resource graph.",
                    "Please only make necessary changes.",
                    "Keep a resource the same unless a change is strictly required.",
                  ].join(" "),
                },
                {
                  role: "assistant",
                  content: ctx.output.script,
                },
              ]
            : [];

        const messages = [
          {
            role: "system" as const,
            content: system,
          },
          ...updateContext,
          ...(typeof prompt === "string"
            ? [
                {
                  role: "user" as const,
                  content: prompt,
                },
              ]
            : prompt),
          {
            role: "user" as const,
            content:
              "Please produce a single ```javascript``` block of code representing the graph by constructing the resource instances, e.g. new <resourcename>(<id>, <input>).",
          },
        ];

        const response = await generateText({
          model,
          messages,
        });

        const _script = extractTypeScriptCode(response.text);
        if (!_script) {
          throw new Error("No script found in response");
        }
        script = _script;
      }

      const resources: ResourceGraph<Resources> = {};

      await evaluate(
        script,
        Object.fromEntries(
          options.resources.map((resource) => {
            const provider = resolveProvider(resource);

            return [
              provider.type,
              new Proxy(provider, {
                construct(target, args: [string, any, ...any[]]) {
                  const id = args[0];
                  const instance = new target(...args);
                  resources[id] = instance as any;
                  return instance;
                },
              }),
            ];
          }),
        ),
      );

      return {
        script,
        resources,
      };
    },
  ) as any;
}

function evaluate(
  script: string,
  context: {
    [type: string]: Provider;
  },
) {
  console.log(script);
  // console.log(context);
  // Create a function that runs the script with the context as "this"
  const fn = new Function("with(this) {\n" + script + "\n}");
  return fn.call(context);
}

// export class Backend extends Agent(
//   "Backend",
//   {
//     resources: [
//       DatabaseSchema,
//       RestAPI,
//       Authorization,
//       Notifications,
//       Payments,
//       Email,
//       SMS,
//     ],
//   },
//   async (ctx, props) => {
//     ctx;
//     props;
//   },
// ) {}
